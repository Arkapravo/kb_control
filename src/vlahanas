//I modified your code to make it a little more modular and user friendly.
//This way it is easier to read and also easier to make modifications-additions.
//I do not have linux, ros, and whatever it needs to be tested, so it might have small typos etc,
//but you can give it a try and fix any issues.
//Vasileios Lahanas

#include <termios.h>
#include <unistd.h>
#include <fcntl.h>
#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <stdio.h>

/*
  * kbhit : Similat to the kbhit function of windows.
	* Waits for user input in the terminal, in a non blocking manner.
*/
int kbhit(void)
{
	struct termios oldt, newt;
	int ch;
	int oldf;

	tcgetattr(STDIN_FILENO, &oldt);
	newt = oldt;
	newt.c_lflag &= ~(ICANON | ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &newt);
	oldf = fcntl(STDIN_FILENO, F_GETFL, 0);
	fcntl(STDIN_FILENO, F_SETFL, oldf | O_NONBLOCK);

	ch = getchar();

	tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
	fcntl(STDIN_FILENO, F_SETFL, oldf);

	if(ch != EOF)
		{
		ungetc(ch, stdin);
		return 1;
		}

	return 0;
}




/*
	* msgInit : Initialize cmdvel 
*/
bool initializeMsg()
{

}



class robot
{

public:
	//Declare cmdevl as global
	geometry_msgs::Twist cmdvel;
	int currentAction;

	//Initialize robot
	robot()
	{
		//Initialize robot velocities
		cmdvel.linear.y=0;
		cmdvel.linear.z=0;
		cmdvel.angular.x=0;
		cmdvel.angular.y=0;
		cmdvel.angular.z=0;
			
		l_vel=0.25;
		a_vel=1; 	
	}

	~robot()

	void robot::changeSpeed(bool increase)
	{
		//Increase or decrease angular/linear velocity
		if (increase)
		{
			l_vel=l_vel*1.25;
			a_vel=a_vel*1.25;
		}
		else{
			l_vel=l_vel/1.25;
			a_vel=a_vel/1.25;
		}
		
		//Refresh velocities
			switch (currentAction)
			{
			case : 1
					cmdvel.linear.x=l_vel;
            		cmdvel.angular.z=0;
					break;
			case : 2
					cmdvel.linear.x=0;
            		cmdvel.angular.z=-a_vel;
					break;
			case : 3
					cmdvel.linear.x=-l_vel;
            		cmdvel.angular.z=0;
					break;
			case : 4
					cmdvel.linear.x=0;
            		cmdvel.angular.z=a_vel;
					break;
			}
	}

	//Translates user input into useful robot directions
	void robot::readDirection(int direction)
	{
		switch(direction)
		{
			case:65
				currentAction = goForward();
				break;
			case:67
				currentAction = turnLeft();
				break;
			case:66
				currentAction = goBack();
				break;
			case:68
				currentAction = turnRight();
				break;
			case:32
				currentAction = stopMoving();
				break;
		}
	}
 
private:
	
	float l_vel,a_vel;

	int robot:goForward()
	{
		printf("Moving forward\n");
			cmdvel.linear.x=l_vel;
            cmdvel.angular.z=0;
	    return 1;	
	}

	int robot::turnRight()
	{
        printf("Turning right\n");
            cmdvel.linear.x=0;
            cmdvel.angular.z=-a_vel;
	    return 2;
	}

	int robot::turnLeft()
	{
        printf("Turning left\n");
			cmdvel.linear.x=0;
            cmdvel.angular.z=a_vel;
        return 4;   
	}

	int robot::goBack()
	{
        printf("Moving backwards\n");
            cmdvel.linear.x=-l_vel;
            cmdvel.angular.z=0;
        return 3; 
	}

	int robot::stopMoving()
	{
        printf("Stopped\n");
			cmdvel.linear.x=0;
            cmdvel.angular.z=0;
			///            vel_pub.publish(cmdvel);
        return 0; 
	}


 
};



/*
	*
	* Main function
	*
*/
int main(int argc, char** argv)
{
	
    char userInput;

	/* Initialize ros */
    ros::init(argc, argv, "move_robot_1");

    //printf("Node Started \n");
    ros::NodeHandle nh;
    ros::Publisher vel_pub;


    vel_pub = nh.advertise<geometry_msgs::Twist>("cmd_vel",1);

	robot* myRobot = new robot();

    puts("** KEYBOARD CONTROLLED TELEOPERATION **");
    puts("#.1 use arrow keys to navigate");
    puts("#.2 x/z to increase/decrease speed by 25%");
    puts("#.3 press spacebar to stop the robot");

    while(1)
    {
        
         while(!kbhit());
         userInput = getchar();
	
		if(userInput =='x')
		{
			myRobot->changeSpeed(true);	
		}
        else if(userInput =='z')
		{
			myRobot->changeSpeed(false);	
		}else
		{
			myRobot->readDirection(userInput);	
		}
     
        vel_pub.publish(myRobot->cmdvel);    

		//Exit while loop when space is hit...
		if(userInput == ' ') break; 
    }

    ros::spin();
    return 0;
}
